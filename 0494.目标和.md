# 解题关键点

- 第一反应是动态规划，不过因为 nums 比较小（1~20），还是先试了试 BFS 暴力求解
  - 时间复杂度 O(2^n) 空间复杂度 O(2^n)。（居然还能打败 50% 的敌人）
- 动态规划的方案待补

# 代码

```rust
impl Solution {
    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        use std::collections::HashMap;
        let mut map:HashMap<i32, i32> = HashMap::new();
        map.insert(nums[0], 1);
        // entry(key) 返回一个 Entry 对象
        // and_modify() 如果 Entry 存在值，则执行闭包。由于会返回当前 Entry 实例，因此可以和 or_insert 链式执行
        // or_insert() 如果 Entry 不存在值，则插入新的值，同时返回当前值的可变引用
        map.entry(-nums[0]).and_modify(|e| *e += 1).or_insert(1);
        for n in &nums[1..] {
            let mut newmap:HashMap<i32, i32> = HashMap::new();
            // BFS，不断对计算结果进行累加
            for (k, v) in map.iter() {
                newmap.entry(k + *n).and_modify(|e| *e += v).or_insert(*v);
                newmap.entry(k - *n).and_modify(|e| *e += v).or_insert(*v);
            }
            map = newmap;
        }
        // 最后返回 target 位置的值，如果不存在，返回 0
        *map.entry(target).or_insert(0)
    }
}
```

# 测试用例

```rust
assert_eq!(find_target_sum_ways(vec![0], 0), 2);
assert_eq!(find_target_sum_ways(vec![0], 2), 0);
assert_eq!(find_target_sum_ways(vec![1, 1, 1, 1, 1], 3), 5);
assert_eq!(find_target_sum_ways(vec![0, 1, 1, 2, 2], 0), 8);
assert_eq!(find_target_sum_ways(vec![0, 1, 1, 2, 2, 0, 1, 1, 2, 2, 0, 1, 1, 2, 2, 0, 1, 1, 2, 2], 0), 129472);
```
