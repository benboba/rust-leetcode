# 解题关键点

- 第一反应是动态规划，不过因为 nums 比较小（1~20），还是先试了试暴力求解
  - 利用 HashMap 存储当前所有的计算结果，使用当前值和所有计算结果进行运算，再存储到新的 HashMap
    - 时间复杂度 O(n^2) 空间复杂度 O(n^2)。（好像这个解法的时间复杂度和动态规划相当，只是每次创建 HashMap 导致慢了一点点）
  - 试了一下 DFS 回溯，时间复杂度 O(2^n) 空间复杂度 O(1)，居然没有 TLE
- 动态规划

# 代码

BFS：

```rust
impl Solution {
    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        use std::collections::HashMap;
        let mut map:HashMap<i32, i32> = HashMap::new();
        map.insert(nums[0], 1);
        // entry(key) 返回一个 Entry 对象
        // and_modify() 如果 Entry 存在值，则执行闭包。由于会返回当前 Entry 实例，因此可以和 or_insert 链式执行
        // or_insert() 如果 Entry 不存在值，则插入新的值，同时返回当前值的可变引用
        map.entry(-nums[0]).and_modify(|e| *e += 1).or_insert(1);
        for n in &nums[1..] {
            let mut newmap:HashMap<i32, i32> = HashMap::new();
            // 不断对计算结果进行累加
            for (k, v) in map.iter() {
                newmap.entry(k + *n).and_modify(|e| *e += v).or_insert(*v);
                newmap.entry(k - *n).and_modify(|e| *e += v).or_insert(*v);
            }
            map = newmap;
        }
        // 最后返回 target 位置的值，如果不存在，返回 0
        *map.entry(target).or_insert(0)
    }
}
```

DFS：

```rust
fn sum_recursion(nums: &Vec<i32>, target: i32, sum: i32, i: usize, mut res: i32) -> i32 {
    if i == nums.len() {
        if sum == target {
            res += 1;
        }
    } else {
        res += sum_recursion(&nums, target, sum + nums[i], i + 1, res) + sum_recursion(&nums, target, sum - nums[i], i + 1, res);
    }
    res
}

impl Solution {
    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        sum_recursion(&nums, target, 0, 0, 0)
    }
}
```

# 测试用例

```rust
assert_eq!(find_target_sum_ways(vec![0], 0), 2);
assert_eq!(find_target_sum_ways(vec![0], 2), 0);
assert_eq!(find_target_sum_ways(vec![1, 1, 1, 1, 1], 3), 5);
assert_eq!(find_target_sum_ways(vec![0, 1, 1, 2, 2], 0), 8);
assert_eq!(find_target_sum_ways(vec![0, 1, 1, 2, 2, 0, 1, 1, 2, 2, 0, 1, 1, 2, 2, 0, 1, 1, 2, 2], 0), 129472);
```
