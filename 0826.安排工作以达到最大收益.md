# 解题关键点

- 算法 1
    - 工作难度和工作收益是相关联的，所以按照工作收益从大到小排列，然后遍历工人找到第一个难度匹配的工作，把收益累加就可以了。
    - 这个算法的时间复杂度是O(n\*logn) + O(n\*m)
- 算法 2
    - 按照工作难度进行排序，然后更新每个工作难度下的最大收益（如果更简单的工作收益更高，则覆盖掉原有收益），最后遍历工人，用二分查找找到可执行的最高难度的任务即可
    - 这个算法的时间复杂度是 O(n\*logn) + O(m\*logn)

# 代码

```rust
// 这里定义了一个Work结构用于辅助排序
struct Work {
    difficulty: i32,
    profit: i32,
}
impl Work {
    pub fn new(difficulty: i32, profit: i32) -> Self {
        Work {
            difficulty,
            profit,
        }
    }
}

impl Solution {
    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, worker: Vec<i32>) -> i32 {
        let mut works: Vec<Work> = Vec::new();
        for i in 0..difficulty.len() {
            // 首先创建 works 列表
            works.push(Work::new(difficulty.get(i).unwrap().clone(), profit.get(i).unwrap().clone()));
        }
        // 对 works 进行排序
        // sort_by(|a, b|) 拿到 a 和 b 两个虚拟变量，然后 a.cmp(b) 按照从小到大排列，b.cmp(a) 按照从大到小排列
        works.sort_by(|a, b| b.profit.cmp(&a.profit));
        let mut res: i32 = 0;
        // 遍历工人（因为每个任务可以做多次，所以工人无需排序）
        for i in worker {
            // 'tag: 用于作为循环的标签
            'inner: for j in &works {
                if j.difficulty <= i {
                    res += j.profit;
                    // break 内部循环
                    break 'inner;
                }
            }
        }
        res
    }
}
```

优化了一下，改用元组代替自定义结构，代码简洁了不少，但是为啥变慢了……

```rust
impl Solution {
    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, worker: Vec<i32>) -> i32 {
        let mut works: Vec<(i32, i32)> = Vec::new();
        for i in 0..difficulty.len() {
            works.push((difficulty.get(i).unwrap().clone(), profit.get(i).unwrap().clone()));
        }
        works.sort_by(|a, b| b.1.cmp(&a.1));
        let mut res: i32 = 0;
        for i in worker {
            for j in &works {
                if j.0 <= i {
                    res += j.1;
                    break;
                }
            }
        }
        res
    }
}
```

算法 2 的代码

```rust
impl Solution {
    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, worker: Vec<i32>) -> i32 {
        待续
    }
}
```

# 测试用例

```rust
assert_eq!(max_profit_assignment(vec![2,4,6,8,10], vec![10,20,30,40,50], vec![4,5,6,7]), 100);
assert_eq!(max_profit_assignment(vec![2,4,6,8,10], vec![10,20,30,40,50], vec![0]), 0);
```
